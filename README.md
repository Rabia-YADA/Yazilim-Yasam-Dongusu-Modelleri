# Yazilim-Yasam-Dongusu-Modelleri

Yazılım Yaşam Döngüsü Nedir?

Yazılım ürününün üretme, müşteriye teslim etme ve müşterinin kullanma süreci boyunca geçirdiği tüm aşamalara yazılım yaşam döngü süreci denir. Bu süreç Yüksek kalitede yazılımlar ortaya koymak , geliştirmek ve test etmek amacıyla yazılım endüstrisi tarafında kullanılmaktadır. Yazılım yaşam döngüsü yazılım ürününü müşteri gereksinimlerine en uygun ve planlı bir şekilde geliştirmeye yöneliktir. Geliştirme sürecinin zamana dayalı ve içerik olarak bölünmüş aşamalardan oluşması sürecin planlı ilerlemesini sağlamaktadır. Gereksinimler ve yazılım işlevleri dinamiktir. Sürekli biçimde değişmekte ve geçirdiği değişimlerle genişlemektedirler. Bu durum söz konusu aşamaları doğrusallıktan uzak sürekli bir döngü biçiminde ele almaktadır. Bu döngüsel yapı ile herhangi bir aşamada geriye dönmek, geliştirmeyi yapmak ve tekrar ilerlemek mümkündür. Yazılım Yaşam Döngüsü yazılım geliştirmede ve bakımda uluslararası standarttır.

Yazılım Yaşam Döngüsü Aşamaları
Yazılım Yaşam Döngü Aşamalarının sayısı bir çok kaynaklarda değişkenlik göstermektedir. Bu aşamalar 4 aşama ve 10 aşama arasında değişmektedir. Bu makalede 7 aşama değerlendirilmiştir.
Bu Aşamalar:
⦁ Planlama
⦁ Analiz
⦁ Tasarım
⦁ Geliştirme
⦁ Test
⦁ Uygulama
⦁ Bakım
aşamalarından oluşmaktadır.

Yazılım Yaşam Döngüleri Aşamaları
Planlama: İlk olarak müşterinin dikkatli bir şekilde dinlenilmesiyle müşteri istek ve ihtiyaçları tam ve net olarak belirlenir. Bu durum gereksinim analizinin ilk adımıdır. Planlama ise yazılım projesinin planlamasının yapıldığı, yazılım, donanım ve personel gereksinimlerinin çıkarıldığı, personeller arası görev dağılımının yapıldığı ilk kısımdır.
Analiz: Yazılım gereksinim ve işlevleri bu aşamada ayrıntılı bi şekilde çıkarılmaktadır. Yazılım projesinin ne kadar süreceği ve ne gibi risklerin olacağı belirlenmektedir, bu aşamada.
Tasarım: Analiz aşamasında belirlenen yazılım gereksinimlerine çözüm olacak yazılımın ilk halinin oluşturulması aşamasıdır. Kod kullanılmaz. Yazılım projesinin nasıl sürdürüleceğini tasarlama aşaması olarak da düşünülebilir.
Gerçekleştirim: Bu aşamada diğer aşamalarda belirtilen plan ve tasarımla sistemin kodlanması yapılmaktadır. Kodlama aşaması planlama ve tasarım aşamalarında belirtilen programlama dili, geliştirme ortamı ve teknolojilerle yapılmaktadır.
Bu aşama 3'e ayrılır. Bunlar:
⦁ Kodlama
⦁ Test Etme
⦁ Kurulum
Bakım: Bu aşama yazılım projesinin ürün olarak gerçek ortama sunulduktan sonra hata giderme, güncelleme, bakım olayları yapılmaktadır.Bu aşamanın daha etkin ve en iyi sonucu vermesi için yazılım yaşam döngüsü modelleri kullanılabilir.

Yazılım Yaşam Döngüsü Modelleri
Yazılım yaşam döngüsü modelleri birden fazla modellerden oluşmaktadır. Bu durum projelerin büyüklüğü, yazılım projelerinin kimler tarafından kullanılacağı ile ilgilidir. Bu modeller, yazılım yaşam döngüsü aşamalarının izleniş sırası ve oluşan feedbackler ile geliştirilmiştir.
Bu modeller:
⦁ Kodla ve Düzelt
⦁ Gelişigüzel Model
⦁ Barok Modeli
⦁ Çağlayan/Şelale Modeli (Waterfall Model)
⦁ V Modeli
⦁ Helezonik Model (Spiral Model)
⦁ Evrimsel Geliştirme Modeli
⦁ Artırımsal Geliştirme Modeli

Barok ve Gelişigüzel Yaşam Döngü Modelleri
Gelişigüzel Model: 1960'larda kullanılmıştır. Belirli bir yöntemi ve modeli yoktur. Kişiye özel kullanıldığı için takip ve gözetimi oldukça zordur. Bu süreçle oluşturulan uygulamaların okunurluğu ve bakımı oldukça zordur.
Barok Modeli: 1970'lerde kullanılmıştır. Bu modelde döngü yoktur. Yazılım yaşam döngüsü adımları temel olarak gözden geçirilir. Bu modelde belgeler bağımsız bir süreçte ele alınmıştır.
Bu iki model güncel bir yaşam döngü modeli olarak adlandırılamaz. Günümüzde iki model de kullanılmamaktadır.

Şelale Modeli(Waterfall Model)
Şelale modeli yazılım geliştirme sürecinin ilk yayınlanmış modelidir.(1970) Bu yüzden diğer modellerin temeli niteliği taşımaktadır. Bu modeldeki gelişim yaşam döngü aşamalarının her birini en az bir ez tekrar eder. Geleneksel bir modeldir. Modelin statik yapısı yazılım projelerinin dinamik ve esnek yapısı ile uyuşmaz. Bu yüzden bu model çok iyi analiz edilmiş, kısa sürede bitebilecek projeler için kullanılmaktadır.Bu modelde bir etkinlik tamamlandıktan sonra geri dönülmez.

Şelale Modelinin Avantajları ve Dezavantajları
Avantajları
⦁ Kullanılması ve anlaşılması basittir.
⦁ Yönetimi kolaydır.
⦁ Daha az kapsamlı ve gereksinimleri iyi belirlenmiş projelerde için kullanılır.
Dezavantajları
⦁ Karmaşık ve büyük projeler iççin uygun değildir.
⦁ Esnek değildir. Projede yapılan herhangi bir değişiklik maliyeti arttırır.
⦁ Değişime açık olmaması müşteri memnuniyetini azaltır.
⦁ Model aşamalardan oluşmaktadır. Ve ürün son safhada tamamlanır. Gereksinimleri iyi tanımlanmamış projeler için bu durum projenin iptal olmasına sebebiyet verebilir.

V Süreç Modeli
Bu model belirsizliğin az olduğu ve iş tanımlamaların belirgin olduğu projelerde kullanılmaktadır. İstenilen ürün statik olmalıdır. değişkenlik göstermemelidir. Teknoloji e değişkenlik göstermemeli ve proje ekibi tarafınca iyi bilinmelidir. Bu model Şelale Model’inin gelişmiş halidir. Bu model onaylama ve doğrulama içermektedir.
Bu modelde ‘V’ yapısında bir yol izlenmektedir. Sol kısım üretimi sağ kısım ise test işlemini ifade eder. Bu döngü “Kullanıcı Modeli”, “Mimari Modeli” ve “Gerçekleştirim Modeli” olmak üzere 3 çıktıdan oluşur. Kullanıcı modelinde proje geliştirme sürecinin kullanıcı ile ilişkileri tanımlanmaktadır. Sistem ile ilgili planlar ve sistemi kullanıcıya nasıl kabul ettirmeye ilişkin sınama yöntemleri oluşturulmaktadır. Mimari modelde sistem tasarımı ve bunların deneme işlemlerine ilişkin yöntem ve işlemler oluşturulmaktadır. Gerçekleştirim modelinde ise yazılım ölçütlerinin kodlanması ve bunların sınanması işlemleri yapılmaktadır. Tüm bu aşamalarda ‘V’ modeli kullanıcının projeye katkısını arttırmaktadır.

‘V’ Modelinin Avantajları ve Dezavantajları
Avantajları
⦁ Basit, kolay, anlaşılır ve kullanılırdır.
⦁ Gereksinimleri iyi belirlenmiş küçük projeler için iyi sonuçlar verir.
⦁ Belirli aşamalar ve süreçler vardır. Bu da modeli sağlamlaştırır, yönetilmesini kolaylaştırır.
Dezavantajları
⦁ Karmaşık ve nesne tabanlı büyük projeler için kullanışlı değildir.
⦁ Uzun ve devam eden projeler için kullanışsızdır.
⦁ Geriye dönüp değişiklik yapmak oldukça zordur.

Helezonik (Spiral) Model
Spiral dönemi ilk kez 1988 yılında Barry Boehm tarafından tanımlanmıştır. Bu model Şelale modelinden farklı belli ve doğrusal bir akıştan uzak iteratif bir modeldir. Bu modelde risk analizi ön plandadır. BU durum da oluşacak hataları erkenden fark etme ve giderme imkanı sunmaktadır. her bir iterasyon tasarım hedefi ile başlamaktadır. İterasyon müşteri yorumları ve görüşleri ile son bulmaktadır. Bu durum da müşterinin her aşamada yazılım projesinin bir parçasını görmesini sağlamaktadır. Böylelikle bu model projede oluşacak olan sorunların azalmasını sağlamaktadır. Her iterasyon önceki iterasyonun sonuçlarından faydalanarak gelişmektedir. Bu durum iterasyonların iş değerini yakalamayı hedeflemesiyle ilişkilidir. Spiral modeli ‘Planlama’, ‘Risk Analizi’, ‘Üretim’ ve ‘Kullanıcı Değerlendirme’ olmak üzere 4 temel aşamadan oluşmaktadır. Planlama kısmında her aşamada olan ara ürün için bir planlama yapılmaktadır. Risk Analizi kısmında risklerin araştırılması, belirlenmesi ve çözülmesi yapılmaktadır. Üretim kısmında ara ürün ve ürün üretilmektedir. Kullanıcı Değerlendirme kısmında ise ara ürünün oluşturulmasından sonra müşteri görüşlerinin alınıp değerlendirilmesi yapılıp diğer aşamaya geçilmektedir.

Helezonik (Spiral) Modelin Avantajları ve Dezavantajları
Avantajlar
⦁ Değişim ihtiyaçlarını karşılayabilir.
⦁ Kullanıcılara sistemi baştan görme imkanı verir.
⦁ Daha küçük parçalarla geliştirme sürecini yürüttüğünden iyi risk yönetimine sahiptirler.
Dezavantajları
⦁ Yönetimi daha karmaşıktır.
⦁ Projenin sonu başlangıçta görmek mümkün olmayabilir, belirsizdir.
⦁ Küçük projeler için çok daha karmaşık ve maliyetli olabilir.
⦁ Çok sayıda ara aşama çok fazla dokümantasyon gerektirir.
⦁ Spiral süresiz olarak sürebilir.

Artımlı Geliştirme Modeli
Bu modelde proje parçalara bölünmektedir. Artımlı geliştirme modeli başta basit bir yazılım ihtiyacı karşılamak amacıyla başlar zamanla müşteri isteklerini karşılar halde yazılımı geliştirmektedir. Bu modelde oluşturulan parçalarla birer ara ürün geliştirilmektedir. Ara ürünler her seferinde öncekini geliştirip üstüne katarak oluşturulmaktadır. Böylelikle bir yandan üretim bir yandan da kulanım kısmı sürmektedir. Artımlı geliştirme modeli uzun zaman sürecek yazılımlar için uygundur. Bu modelin diğer modellerden kısıtlı sayıda elemanla iş yapabilme gibi üstünlüğü vardır. Bu model doğal olarak yinelemelidir. Tüm döngülerin sonunda yeniden kullanılabilir ürün fonksiyonellik kazanmış şekilde ortaya çıkmaktadır.

Artımlı Geliştirme Modelinin Avantajları ve Dezavantajları
Avantajları
⦁ Sistem için gereksinimler müşterilerle belirlenir.
⦁ Gereksinimlerin önemine göre sıra oluşturulur. Ve gereksinim önemine göre ara ürünler belirlenir.
⦁ İlk olarak en önemli gereksinimi karşılayan çekirdek bir sistem oluşturulur.
⦁ Bu modelle projenin başarısız olma riski azaltılır.
Dezavantajları
⦁ Deneyimli personel gerektirir.
⦁ Parçaları oluşturmak için tüm sistemin tanınmasına gerek vardır.
⦁ Bir ara ürünün sonlanıp diğerinin başlamasına kadar herhangi bir değişiklik yapılamaz.

Kodla ve Düzelt Yaşam Döngü Modeli
Resmi olmayan bir iş fikri ile ortaya çıkar. Doğrudan ürün gerçekleştirilir. Ürün oluşturulana ve gerekli zaman dolana kadar ‘kodlama’ yapılarak devam eder.

Kodla ve Düzelt Yaşam Döngü Model’inin Avantajları ve Dezavantajları
Avantajları
⦁ Bir plana ihtiyaç duymaz.
⦁ Kısa ömürlü prototipler ve çok küçük projeler için kullanışlıdır.
⦁ Deneyimli uzman görüşüne ihtiyaç düşüktür.
Dezavantajları
⦁ Kaynak planlaması yoktur.
⦁ Kontrollü değildir.
⦁ Oluşacak Hataları bulma zordur.
⦁ Kodları düzeltmek maliyetli olabilir.
⦁ Kullanıcı ihtiyaçlarını karşılayamama ihtimali yüksektir.
⦁ Bir planı olmadığından esnek değildir. Kodlarda değişikler yapmak zordur.

Evrimsel Geliştirme Modeli
Diğer modellerle kıyaslandığında ilerleyişi daha yavaş olsa da ilk tam ölçekli modeldir. Ortaya çıkartılan ürün her aşamada tam işlevselliğe sahiptir. Bu modelin başarısı ilk evrimin başarısına bağlıdır.
